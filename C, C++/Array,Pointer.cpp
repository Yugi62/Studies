#include "stdafx.h"
#include <iostream>

using namespace std;

//Array,Pointer
////////////////////

/*
&,*에 대해서)

	&는 주소를 참조하는 연산자이다

		&a				: 변수는 앞에 &를 붙이는 것으로 주소를 알 수 있다
		&array[0]		: 배열은 배열 요소에 &를 붙이는 것으로 그 요소의 주소를 알 수 있다


	*는 메모리 공간에 저장된 값을 참조하는 연산자이다

		*a				: a에 들어있는 주소를 통해 안에 있는 값을 알 수 있다
		*array			: array[0]의 값을 알 수 있다
		*(array + 1)	: array[1]의 값을 알 수 있다


	*&가 만나면 서로 상쇄한다


유의 사항)

	1. 배열명은 배열의 시작을 가리키는 포인터이되 배열이 선언될 때 메모리가 할당되므로 이 포인터는 변할 수 없는 상수값이다.
	2. 배열명은 포인터 상수이기 때문에 배열끼리는 대입할 수 없다.
	3. sizeof 연산자의 피연산자로 사용될 때만은 포인터로 취급되지 않고 배열 그 자체로 취급된다.
	4. 배열이 매개변수로 사용될 때 '*' 상관없이 포인터로 취급된다. ([]를 *로 취급)

	void Display(int arr[]) 여기에서 'arr'은 int형 포인터

*/

int main()
{
	//1차원 배열과 포인터
	////////////////////
	int arr1[3] = { 1,2,3 };


		//1차원 배열의 이름은 배열의 시작 주소이다

		cout << arr1 << endl;		// arr1 = &arr1[0]
		cout << arr1 + 0 << endl;	// arr1 + 0 = &arr1[0]  
		cout << arr1 + 1 << endl;	// arr1 + 1 = &arr1[1]


	//2차원 배열과 포인터
	////////////////////
	int arr2[2][2] = { 1,2,3,4 };


		//2차원 배열은 배열 요소에 &를 붙이는 것으로 그 요소의 주소를 알 수 있다
		cout << &arr2[0][0] << endl;

		//2차원 배열의 이름은 시작 주소이다		
		cout << arr2 << endl;			// arr2 = &arr2[0][0]
		cout << arr2 + 0 << endl;		// arr2 + 0 = &arr2[0][0]
		cout << arr2 + 1 << endl;		// arr2 + 1 = &arr2[1][0]


		//2차원 배열의 행의 요소는 행을 대표하는 주소이다		
		cout << arr2[0] << endl;		// arr2[0] = &arr2[0][0]
		cout << arr2[1] << endl;		// arr2[1] = &arr2[1][0]


		//2차원 배열에서 *(array + i)는 주소를 표현한다
		cout << *(arr2 + 0) << endl;	// *(arr2 + 0) = &arr2[0][0]
		cout << *(arr2 + 1) << endl;	// *(arr2 + 1) = &arr2[1][0]


		//*은 2차원 배열 요소에 저장된 값을 참조하는 연산자이다
		cout << *&arr2[0][0] << endl;		// *&arr2[0][0] = arr2[0][0]
		cout << *(arr2[0] + 0) << endl;		// *(arr2[0] + 0) = arr2[0][0]
		cout << *(*(arr2 + 0) + 0) << endl;	// *(*(arr2 + 0) + 0) = arr2[0][0]


		//'*'이 '+'보다 우선 순위가 높아 괄호를 제대로 쳐야 한다
		cout << *arr2[0] + 1 << endl;		// *arr2[0] + 1 = arr2[0][0] + 1
		cout << **(arr2 + 0) + 1 << endl;	// **(arr2 + 0) + 1 = arr2[0][0] + 1


	//배열의 크기
	////////////////////

		//1차원 배열
		sizeof(arr1);		//배열의 크기 (모든 요소 * 타입)

		//2차원 배열		
		sizeof(arr2);		//배열의 크기 (모든 요소 * 타입)
		sizeof(arr2[0]);	//배열의 열 크기 (열 요소 * 타입)


	//주소의 가감산
	////////////////////

		/*
			C/C++에서 주소는 16진수로 이루어진 수로 정수를 더하거나 빼는 것이 가능하다

			int array[3] = {1,2,3};

			cout << array + 1 << endl;

			그렇기에 위와 같이 array라는 주소에 1을 더하면 당연히 1이 더해진다고 생각할 것이다
			
			하지만 실제로 1을 더해버리면
			cout << *(array + 0) << endl; (=1)
			cout << *(array + 1) << endl; (=2)

			위와 같은 코드가 전혀 성립할 수 없게 된다

			int형 배열은 요소를 저장하기 위해 각 요소당 4바이트를 할당하는데,
			이 말은 즉슨 int형 배열의 다음 값을 참조하기 위해서는 최소 4바이트는 움직여야 한다는 것이다

			결국 실제로 1을 더해버리게 되면 고작 1바이트 밖에 움직이지 못했기에 배열의 다음 값을 참조하는 것은 불가능하다


			그렇다면 위에 있는 코드가 성립하는 이유에 대해서 의문점이 생기게 되는데, 그 이유는 컴파일러가 자동으로 수를 타입에 맞추어 변환해주기 때문이다

			int형 주소 + 1		//실제로는 4를 더한다
			double형 주소 + 1	//실제로는 8을 더한다
		*/

	return 0;
}
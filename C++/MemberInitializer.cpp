#include "stdafx.h"
#include <iostream>

using namespace std;

//MemberInitializer
////////////////////

/*
멤버 이니셜라이저 : 멤버 변수들을 초기화 시켜주는 문법


멤버를 초기화 시켜주는 문법이기에 생성자 대신으로 쓸 수 있지만 몇가지 특정 멤버의 경우
생성자에서는 초기화를 시켜줄 수 없기에 반드시 '멤버 이니셜라이저'를 사용해야 한다
 1. 상수 멤버 초기화
     상수 멤버의 경우 선언과 동시에 초기화가 필수적인데 클래스의 경우 이를 뒤로 미루는 것이 가능하다.
	 하지만 그렇다고 무턱대고 생성자에서 대입 연산자로 값을 넣으려고 하면 오류가 나게 되는데, 그 이유를
	 잘 생각해보면 생성자가 실행되었다는 것은 그 객체가 만들어졌다는 것이므로 상수 멤버 또한 생성된 것이다. 
	 그 결과 아무 값이 들어있지 않아도 이미 실체화된 상태에서는 상수의 특정 문법이 적용되기에 결과적으로 컴파일러는 이것을 
	 오류로 본다. 이를 해결하려면 객체가 실체화되기 전에 초기화해주는 특정한 문법이 필요한데 그것이 바로 '멤버 이니셜라이져'이다.

 2. 레퍼런스 멤버 초기화
     레퍼런스 또한 마찬가지로 선언과 동시에 초기화가 필요한데, 생성자에서 대입연산자로 초기화를 하려고 하면 아무것도 참조하지 않은 레퍼런스에 
	 변수를 참조하라는 것이 아닌 변수의 값을 넣으려는 식이 되어버려 당연하겠지만 오류가 발생하게 되므로 이 역시 '멤버 이니셜라이져'로 초기화해야 한다.

 3. 포함된 객체 초기화
     생성자는 객체 실행과 동시에 실행되는 함수이다. 이것은 생성자에서 포함된 객체를 초기화하지 못 하는 이유이기도 한데, 생성자가 실행되었다는 것은 즉
	 이미 객체가 만들어졌다는 뜻이기 때문이다. 이 때문에 포함된 객체를 생성자 내부에서 초기화 할 수 없으므로 '멤버 이니셜라이져'를 사용해야 한다.

 4. 부모클래스의 멤버 변수 초기화
     상속된 상황에서는 부모가 만들어진 후 자식이 만들어지는데 그렇다면 생성자 역시 부모가 먼저 실행되야 될 것이다. 하지만 자식에서 일반적인 방법으로
	 부모의 생성자가 먼저 실행시킬 수 있는 방법이 없는데 왜냐하면 무슨 짓을 해도 자식 생성자가 먼저 실행되기 때문이다. 이 때문에 상속 관게에 있어서도
	 생성자 보다 속도가 더 빠른 '멤버 이니셜라이저'를 통해 부모 생성자를 먼저 선언을 해야 한다.

유의 사항)
-생성자보다 먼저 실행된다
*/



class A
{
private:
	const int N;
	int &R;

public:
	A(int _N, int &_R) : N(_N), R(_R) {}
};

class B : public A
{
public:
	B(int _N, int &_R) : A(_N,_R) {}
};